# AUTOGENERATED FILE - DO NOT MODIFY!
# This file was generated by Djinni from using_custom_datatypes.djinni

from djinni.support import MultiSet # default imported in all files
from djinni.exception import CPyException # default imported in all files
from djinni.pycffi_marshal import CPyRecord

from custom_datatype import CustomDatatype
from custom_datatype_helper import CustomDatatypeHelper
from _cffi import ffi, lib

from djinni import exception # this forces run of __init__.py which gives cpp option to call back into py to create exception

from other_record import OtherRecord

class OtherRecordHelper:
    @staticmethod
    def release(c_ptr):
        assert c_ptr in c_data_set
        c_data_set.remove(ffi.cast("void*", c_ptr))

    @ffi.callback("struct DjinniRecordHandle *(struct DjinniRecordHandle *)")
    def get_other_record_f1(cself):
        try:
            _ret = CPyRecord.fromPy(CustomDatatype.c_data_set, CPyRecord.toPy(None, cself).customDatatypeData)
            assert _ret != ffi.NULL
            return _ret
        except Exception as _djinni_py_e:
            CPyException.setExceptionFromPy(_djinni_py_e)
            return ffi.NULL

    @ffi.callback("struct DjinniRecordHandle *(struct DjinniRecordHandle *)")
    def create_other_record(customDatatypeData):
        py_rec = OtherRecord(
            CPyRecord.toPy(CustomDatatype.c_data_set, customDatatypeData))
        return CPyRecord.fromPy(OtherRecord.c_data_set, py_rec) #to do: can be optional?

    @ffi.callback("void (struct DjinniRecordHandle *)")
    def __delete(dh):
        assert dh in OtherRecord.c_data_set
        OtherRecord.c_data_set.remove(dh)

    @staticmethod
    def _add_callbacks():
        lib.other_record_add_callback___delete(OtherRecordHelper.__delete)
        lib.other_record_add_callback_create_other_record(OtherRecordHelper.create_other_record)
        lib.other_record_add_callback_get_other_record_f1(OtherRecordHelper.get_other_record_f1)

OtherRecordHelper._add_callbacks()

